---
title: "Spatial_Analysis_Visium"
author: "Riley Grindle"
date: "2024-04-16"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(dplyr)
library(Matrix)
library(viridis)
library(tidyverse)
library(Seurat)
library(SeuratData)
library(SeuratObject)
library(SeuratWrappers)
library(Seurat.utils)
library(SingleCellExperiment)
library(gprofiler2)
library(ggplot2)
library(ggsankey)
library(DoubletFinder)
library(stringr)
library(patchwork)
library(loupeR)
library(presto)
library(DropletUtils)
library(PCAtools)
library(aKNNO)
library(jsonlite)
library("rstudioapi")  

options(future.globals.maxSize = 1e9)
options(Seurat.object.assay.version = "v5")
```

```{r}
#####################################################################
# FILL OUT **** parameters.json **** BEFORE EXECUTION OF THE SCRIPT #
#####################################################################
path <- gregexpr(pattern ='/',getSourceEditorContext()$path)
knitr::opts_knit$set(root.dir = (substr(getSourceEditorContext()$path, 1, as.vector(path[[1]])[-1])))

tryCatch({
  json_data <- fromJSON("./parameters.json")
},
error = function(err) {
  message(paste0("The file: ", input, " does not seem to exist, or is not in json format."))
  message("Here's the original error message:\n")
  message(conditionMessage(err))
}
)
```


```{r}
# Working Directory
params.workingdirs        <- json_data$working_dir

# 10X Data Input
params.H5_directory      <- json_data$H5_directory

# Output files directory
params.outdir            <- json_data$out_dir

#   List of Sample names (same order as paths) (Names in single quotes) 
#   eg. c('Sample1','Sample2','Sample3')
params.SampleNames       <- json_data$SampleNames
#   Name of project
params.ProjectName       <- json_data$Project_Name       

# Table To Remove unwanted genes
params.FeatureFile       <- json_data$FeatureFile # Custom feature file containing: MSTR \t MSTR::AMEX::GENE \t Gene Expression
params.Orig_Space_features <- json_data$OrigFeatFile  # Original feature file containing:  MSTR \t Annotation \t Gene Expression
params.ID2Gene           <- json_data$ID2GeneFile
params.gene_subset       <- json_data$SubsetGenes

# Subsetting params
params.subset_qc_metrics        <- json_data$SubsetQCmetrics
params.ncount_subset_quantile   <- json_data$ncountQuantile
params.nfeature_subset_quantile <- json_data$nfeatureQuantile
params.maxMitoPct               <- json_data$maxMitoPct

# Gene Lists for Cell Cycle Scoring and MT
#   Currently set to search for pattern. change to a list "c()" for a custom list
params.organism_ls       <- c("MOUSE", "HUMAN")
params.organism          <- toupper(json_data$Organism)
params.mtGeneList        <- json_data$Mito_Genes


# Seurat Scaling
#    in vars to regress, it should be metadata sections to be regressed or genes i.e. eGFP
params.vars2Regress     <- json_data$Vars2Regress


params.cluster_prefix <- json_data$ClusterPrefix

# Post Scale Options
#    True of False: make Loupe File
params.makeLoupe            <- json_data$MakeLoupe
#    List of Resolutions in ascending order ex. c(0.05,0.1,0.3,0.5,0.7,0.9)
params.resolutions          <- json_data$Resolutions 
#    True of False: Run integration
params.integration          <- json_data$Integrating
#    If params.integration set to true, decide which integration method to use. 
#    (options: CCA, RPCA, Harmony, FastMNN) scVIIntegration needs additional setup -- conda-env
params.integrationMethod   <- json_data$IntegrationMethod                          

# Save Final Merged RDS file at end of Script (Good for keeping Progressive Versions of
# Seurat object)
params.saveRdsSO         <- json_data$SaveRDS

```

#### Set working directory if not in a project

```{r}
if(params.workingdirs != ""){
    setwd(params.workingdirs)
}
```


#### Make output directories

```{r}
setwd(params.outdir)

if(!dir.exists("figures/")){
    dir.create("figures/")
}
if(!dir.exists("markers/")){
    dir.create("markers/")
}
```

#### Make output directories

```{r}
setwd(params.outdir)

if(!dir.exists("figures/spatial/")){
    dir.create("figures/spatial")
}
if(!dir.exists("markers/spatial")){
    dir.create("markers/spatial")
}

```

#### Removal of unwanted genes

```{r}
setwd(params.workingdirs[1])

if (params.organism == "AXOLOTL"){

ID2Gene <- read.delim(params.ID2Gene,sep = "\t" ,header = F)
rownames(ID2Gene) = ID2Gene[,1]

unannotated.transcripts = rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("PEG10",ID2Gene$V2)] ]
unannotated.transcripts = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("L1TD1",ID2Gene$V2)] ], unannotated.transcripts))
unannotated.transcripts = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("RTL",ID2Gene$V2)] ], unannotated.transcripts))
unannotated.transcripts = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("GIN1",ID2Gene$V2)] ], unannotated.transcripts))
unannotated.transcripts = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("L1\\-RT",ID2Gene$V2)] ], unannotated.transcripts))
unannotated.transcripts = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("^N\\/A",ID2Gene$V2)] ], unannotated.transcripts))
unannotated.transcripts = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("^AMEX",ID2Gene$V2)] ], unannotated.transcripts))

ID2Gene = ID2Gene[!rownames(ID2Gene) %in% unannotated.transcripts,]

rp.genes = rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("^RPL",ID2Gene$V2)]]
rp.genes = unique(c(rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("^RPS",ID2Gene$V2)] ], rp.genes))

ID2Gene = ID2Gene[!rownames(ID2Gene) %in% rp.genes,]

Features <- read.delim(params.FeatureFile,sep = "\t",header = F)
Features[,2][which(duplicated(Features[,2]))]
rownames(Features) = Features[,2]

Features <- Features[Features$V1 %in% rownames(ID2Gene),]

}
```

#### Create Seurat from Spatial Experiment

```{r}
setwd(params.workingdirs[1])

NameSO <- paste0("SO_",params.SampleNames[1], "_SPAT")
assign(NameSO, Load10X_Spatial(data.dir = params.H5_directory, filter.matrix = F))

```

# Feature Name Editing of Seurat Object

```{r}
setwd(params.workingdirs[1])

if (params.organism == "AXOLOTL"){
SO <- get(NameSO)

# Custom Feature File
features <- read.delim(params.FeatureFile,sep = "\t",header = F)

# Original Spaceranger feature file output
inFeatures <- read.delim(params.Orig_Space_features, sep = "\t", header = F)

inFeatures$ordering <- row.names(inFeatures)

inFeatures$ordering <- str_pad(inFeatures$order, 6, pad = "0" )

outFeatures <- merge(features,inFeatures,by.x = 1,by.y = 1, all = T)

outFeatures <- outFeatures[order(outFeatures$ordering),]

SO.rn <- RenameGenesSeurat(SO,newnames = outFeatures$V2.x, assay = "Spatial")

assign(NameSO, SO.rn)

if (params.gene_subset){
  assign(NameSO, get(NameSO)[which(rownames(get(NameSO)) %in% rownames(Features)),])
} else {
}
}
```
# Removing "_" in gene names 

```{r}
new_features <- rownames(get(NameSO))

for (i in 1:length(new_features)) {
  
  gene <- new_features[i]
  
  gl <- unlist(strsplit(gene, ""))
  
  if ("_" %in% gl) {
    gene <- gsub("_", "-", gene)
  }
  
  new_features[i] <- gene
  
}


SO.rn <- RenameGenesSeurat(get(NameSO),newnames = new_features, assay = "Spatial")
assign(NameSO, SO.rn)

```

# Validate SO 

```{r}
print(get(NameSO))
```

# Calculate MT pct - Spatial

```{r}
if (params.organism == "MOUSE"){
  mito.genes <- row.names(get(NameSO))[grepl(pattern = "^mt-", x = row.names(get(NameSO)))]
  
  calcMT <- function(SO) {
    mito.contig.sampSpec <- intersect(mito.genes , rownames(SO))
    SO[["percent.mt"]] <- PercentageFeatureSet(SO, features = mito.contig.sampSpec)
    SO
}
}else if (params.organism == "HUMAN") {
  mito.genes <- row.names(get(NameSO))[grepl(pattern = "^MT-", x = row.names(get(NameSO)))]
  
  calcMT <- function(SO) {
    mito.contig.sampSpec <- intersect(mito.genes , rownames(SO))
    SO[["percent.mt"]] <- PercentageFeatureSet(SO, features = mito.contig.sampSpec)
    SO
}
}else if (params.organism == "AXOLOTL") {
  mito.genes <- params.mtGeneList
  mito.contig <- c(rownames(ID2Gene)[ID2Gene$V2 %in% mito.genes ], rownames(ID2Gene)[ID2Gene$V2 %in% ID2Gene$V2[grep("^COX",ID2Gene$V2)]] )
  mito.contig <- Features[Features$V1 %in% mito.contig,]
  mito.contig$V2 <- gsub("_","-",mito.contig$V2)
  
  calcMT <- function(SO) {
    mito.contig.sampSpec <- intersect(mito.contig$V2 , rownames(SO))
    SO[["percent.mt"]] <- PercentageFeatureSet(SO, features = mito.contig.sampSpec)
    SO
}
}


print(paste0("Calculating MT% on Sample: ", NameSO))
assign(NameSO, calcMT(get(NameSO)))

```

# Populating SeuratObjList with Spatial Slices

```{r}
SeuratObjList <- c()
SeuratObjList <- append(SeuratObjList, NameSO)
```

#### Normalize Data

```{r}
for (samp in SeuratObjList){
    print(paste0("Normalizing data on Sample: ", samp))
    assign(samp, SCTransform(get(samp), return.only.var.genes = FALSE, assay = 'Spatial', vars.to.regress = params.vars2Regress))
}

```

# Plot QC metrics - Spatial

```{r}
setwd(params.outdir)

samp <- SeuratObjList[1]

plot1 <- VlnPlot(get(NameSO), features = "nCount_Spatial", pt.size = -1) + NoLegend() + xlab(params.SampleNames) + theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
plot2 <- VlnPlot(get(NameSO), features = "nFeature_Spatial", pt.size = -1) + NoLegend() + xlab(params.SampleNames) + theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
plot3 <- VlnPlot(get(NameSO), features = "percent.mt", pt.size = -1) + NoLegend() + xlab(params.SampleNames) + theme(axis.ticks.x = element_blank(), axis.text.x = element_blank())
plot4 <- SpatialFeaturePlot(get(NameSO), features = "nCount_Spatial", pt.size.factor = 2.0) + theme(legend.position = "right")
plot5 <- SpatialFeaturePlot(get(NameSO), features = "nFeature_Spatial", pt.size.factor = 2.0) + theme(legend.position = "right")
plot6 <- SpatialFeaturePlot(get(NameSO), features = "percent.mt", pt.size.factor = 2.0) + theme(legend.position = "right")
plot7 <- FeatureScatter(get(samp), feature1 = "nCount_Spatial", feature2 = "percent.mt", shuffle = T) + theme(legend.title = element_blank(), legend.position = 'none')
plot8 <- FeatureScatter(get(samp), feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial", shuffle = T) + theme(legend.title = element_blank(), legend.position = 'none')

pdf(file = paste0('figures/spatial/',params.ProjectName,"_",samp,'_preFilterQC_Spatial.pdf'), title = paste0(params.ProjectName," ",samp,' PreFilter QC'), width = 11, height = 8.5)
  wrap_plots(plot7, plot8)
  wrap_plots(plot1, plot2, plot3)
  print(plot4)
  print(plot5)
  print(plot6)
dev.off()

wrap_plots(plot7, plot8)
wrap_plots(plot1, plot2, plot3)
  print(plot4)
  print(plot5)
  print(plot6)
  

```


#### Calculate Subsetting Bounds and Subset

##### Subset Seurat objects - SKIP IF SPATIAL (temporarily)

```{r}

setwd(params.outdir)

if (params.subset_qc_metrics){

for (samp in SeuratObjList){
  print(paste0("Calcualting subset bounds on sample: ", samp))
  params.minNCount         <- quantile(get(samp)$nCount_Spatial, probs = params.ncount_subset_quantile)[[paste0((params.ncount_subset_quantile *100), "%")]]
  params.minNFeature         <- quantile(get(samp)$nFeature_Spatial, probs = params.nfeature_subset_quantile)[[paste0((params.nfeature_subset_quantile *100), "%")]]
  

  print(paste0("     Minimum N Count set point:        ", params.minNCount))
  print(paste0("     Minimum N Feature set point:      ", params.minNFeature))
  print(paste0("     Maximum Mito Percent set point:   ", params.maxMitoPct))
  
}

for (samp in SeuratObjList){
    print(paste0("Applying subset bounds on sample: ", samp))
    params.minNCount         <- quantile(get(samp)$nCount_Spatial, probs = params.ncount_subset_quantile)[[paste0((params.ncount_subset_quantile *100), "%")]]
    params.minNFeature         <- quantile(get(samp)$nFeature_Spatial, probs = params.nfeature_subset_quantile)[[paste0((params.nfeature_subset_quantile *100), "%")]]

    assign(samp,subset(get(samp), subset = nFeature_Spatial > params.minNFeature & nCount_Spatial > params.minNCount & percent.mt < params.maxMitoPct))
}

for (samp in SeuratObjList){
    print(paste0("Building PrescaleQC plots on sample: ", samp))
    plot1 <- FeatureScatter(get(samp), feature1 = "nCount_Spatial", feature2 = "percent.mt", shuffle = T)
    plot2 <- FeatureScatter(get(samp), feature1 = "nCount_Spatial", feature2 = "nFeature_Spatial", shuffle = T)
    vplot1 <- VlnPlot(get(samp), features = c("nCount_Spatial","nFeature_Spatial","percent.mt"),pt.size = -1)


    pdf(file = paste0('figures/spatial/',params.ProjectName,"_",samp,'_postFilterQC.pdf'), title = paste0(params.ProjectName," ",samp,' PostFilter QC'), width = 11, height = 8.5)
    print(plot1 + plot2)
    print(vplot1)
    dev.off()
    
    print(plot1 + plot2)
    print(vplot1)
}

}

```


#### Run PCA on individual samples

```{r}
for (samp in SeuratObjList){
    print(paste0("Running PCA on Sample: ", samp))
    all.genes <- rownames(get(samp))
    assign(samp,RunPCA(get(samp), assay = "SCT", features = all.genes ,npcs = 100))
}
```


#### Generate Elbow Plots and Calculate PCs to use

Validate PCs selected

```{r}
setwd(params.outdir)

params.pcMax <- c()
for (samp in SeuratObjList){
    print(paste0("Generating Elbow Plot for Sample: ", samp))
    Elbow <- ElbowPlot(get(samp), ndims = 100, reduction = "pca")
    pdf(paste0("./figures/spatial/",params.ProjectName,"_",samp,"_ElbowPlot.pdf"), 
        width = 20, height = 15)
    print(Elbow)
    dev.off()
    print(Elbow)
    pcCount <- 1
    while(Elbow$data$stdev[pcCount]-Elbow$data$stdev[pcCount+1]>0.01 | Elbow$data$stdev[pcCount+1]-Elbow$data$stdev[pcCount+2]>0.01){
        pcCount <- pcCount + 1
    }
    print(paste0("pc Max Selected at: ", pcCount))
    params.pcMax                <- append(params.pcMax,pcCount) 
}

```

# Set Merged SO = only SO in environment

```{r}
MergedSO <- get(SeuratObjList[1])
```


#### Create Cluster names for unintegrated

```{r}
count <- 1
countMax <- length(params.resolutions)
params.resolutionsNames <- c()
while (count <= countMax){
    resVal <- paste0(params.cluster_prefix,params.resolutions[count])
    params.resolutionsNames <- append(params.resolutionsNames, resVal)
    count <- count + 1
}
params.resolutionsNames
```

#### Find Neighbors

```{r}
MergedSO <- FindNeighbors_aKNNO(MergedSO, dims = 1:params.pcMax, reduction = "pca")
```

#### Find Cluster and Set Idents

```{r}
MergedSO <- FindClusters(MergedSO, resolution = params.resolutions, cluster.name = params.resolutionsNames, graph.name="aKNN_O")
```
# Generate Sankey Plot - SC

```{r}
setwd(params.outdir)

mergedSOmetaRes <- MergedSO@meta.data

if (params.integration == F){
    mergedSOmetaRes <- mergedSOmetaRes[,grepl(params.cluster_prefix,names(mergedSOmetaRes))]
    names(mergedSOmetaRes) <- gsub(params.cluster_prefix,"res",names(mergedSOmetaRes))
}else{
    pattern <- paste0(params.integrationMethod,"Res")
    mergedSOmetaRes <- mergedSOmetaRes[,grepl(pattern,names(mergedSOmetaRes))]
    names(mergedSOmetaRes) <- gsub(pattern,"res",names(mergedSOmetaRes))
}

df <- mergedSOmetaRes%>%
    make_long(names(mergedSOmetaRes))

df$next_node <- str_pad(df$next_node,2, pad = "0")
df$node <- str_pad(df$node,2, pad = "0")

df$reswClust <- paste0(df$x,": ", df$node)

reagg <- df%>%
    dplyr::group_by(reswClust)%>%                                        # Get counts 
    tally()

df2 <- merge(df, 
             reagg, 
             by.x = 'reswClust', 
             by.y = 'reswClust', 
             all.x = TRUE)

pl <- ggplot(df2, aes(x = x,                        
                      next_x = next_x,                                     
                      node = node,
                      next_node = next_node,        
                      fill = factor(node),
                      label = paste0(node, " = ", n))) +                 # Creates lable with node and count
    geom_sankey(flow.alpha = 0.5,                                        # Add opacity
                node.color = "black",                                    # Node Color
                show.legend = TRUE) +                                    # This determines if you want your legend to show
    geom_sankey_label(size = 3,
                      color = "black", 
                      fill = "white") +                                  # This specifies the Label format for each node 
    theme_bw() + 
    theme(legend.position = 'none') + 
    theme(axis.title = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks = element_blank(),
          panel.grid = element_blank()) + 
    scale_fill_viridis_d(option = "H") + 
    labs(title = paste0("Sankey: ",params.ProjectName, ifelse(params.integration ==T,paste0(" Integrated (", params.integrationMethod,")"), " Unintegrated")," Dataset")) + 
    labs(caption =NULL ) + 
    labs(fill = 'Nodes')

### Save Sankey Plot
pdf(paste0("./figures/spatial/",params.ProjectName,"SankeyPlot.pdf"), width = 20, height = 15)
pl
dev.off()

print(pl)
MergedSO[["Spatial"]] <- JoinLayers(MergedSO[["Spatial"]])
```


#### Find Clusters and Generate Markers

```{r}
setwd(params.outdir)

### Find Clusters and Gerenated Markers
for (i in 1:length(params.resolutions)){
    print(paste0("Finding Markers at ",params.resolutions[i]," resolution..."))
    if(params.integration ==T){
        Idents(MergedSO) <- paste0(params.integrationMethod,"Res.",params.resolutions[i])
    }else{
        Idents(MergedSO) <- paste0(params.cluster_prefix,params.resolutions[i])
    }
    assign(paste0("MarkersRes",params.resolutions[i]),FindAllMarkers(MergedSO, only.pos = T, logfc.threshold = 0.3))
}

MergedSO$unintegratedRes.0.05 <- NULL
params.resolutions
# Add in annotation info and output tsv files
for (j in 1:length(params.resolutions)){
    if (length(levels(factor(get(paste0("MarkersRes", params.resolutions[j]))$cluster))) <= 1) {
      next
    }
    print(paste0("Generating Markers tsv at ",params.resolutions[j]," resolution..."))
    markertemp <- get(paste0("MarkersRes",params.resolutions[j]))
    markertemp <- markertemp  %>% arrange(cluster, desc(avg_log2FC))
    markertemp$markercall <- 1
    markertemp <- markertemp %>%
        mutate(markercall = ifelse(avg_log2FC >= 1.7 & markertemp$pct.1/markertemp$pct.2 >= 1.7 & -log10(markertemp$p_val_adj) >= 27, 1, 0))
    assign(paste0("MarkersRes",params.resolutions[j]),markertemp)
    write.table(get(paste0("MarkersRes",params.resolutions[j])), file = paste0("./markers/spatial/",ifelse(params.integration ==T,paste0(" Integrated_", params.integrationMethod,"_"), "Unintegrated"),"MarkersRes",params.resolutions[j],".tsv"), sep = "\t", quote = F,row.names = F)
    rm(markertemp)
}
```


#### Set Default Ident

```{r}
params.identRes             <-   0.3  # Set resolution eg. 0.3 
    
### Set Ident
if(params.integration ==T ){
    Idents(MergedSO) <-paste0(params.integrationMethod,"Res.",params.identRes)
}else{
    Idents(MergedSO) <-paste0(params.cluster_prefix,params.identRes)
}
```

#### Run UMAP and Spatial Dimplot

```{r}
setwd(params.outdir)

MergedSO <- RunUMAP(MergedSO, reduction = "pca", dims = 1:params.pcMax)
pdf(paste0("./figures/spatial/",params.ProjectName,"Spatial_dim_plot","res.",params.identRes,".pdf"), width = 20, height = 15)
p1 <- DimPlot(MergedSO, reduction = "umap", label = TRUE, pt.size = 3)
p2 <- SpatialDimPlot(MergedSO, label = TRUE, label.size = 3, alpha = c(0.9,1), pt.size.factor = 2)
p1 + p2
dev.off()

p1 + p2

```


#### Save RDS

```{r}
setwd(params.outdir)

if(params.saveRdsSO == T){
    if(!dir.exists("RDSObjects")){
        dir.create("RDSObjects")
    }
    if(!dir.exists("RDSObjects/spatial")){
        dir.create("RDSObjects/spatial")
    }
    saveRDS(MergedSO, paste0("./RDSObjects/spatial/",params.ProjectName,"SO.rds"))
}
```





















